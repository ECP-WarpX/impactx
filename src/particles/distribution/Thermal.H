/* Copyright 2022-2023 The Regents of the University of California, through Lawrence
 *           Berkeley National Laboratory (subject to receipt of any required
 *           approvals from the U.S. Dept. of Energy). All rights reserved.
 *
 * This file is part of ImpactX.
 *
 * Authors: Ji Qiang, Axel Huebl
 * License: BSD-3-Clause-LBNL
 */
#ifndef IMPACTX_DISTRIBUTION_THERMAL
#define IMPACTX_DISTRIBUTION_THERMAL

#include <AMReX_Random.H>
#include <AMReX_REAL.H>
#include <AMReX_Print.H>

#include <cmath>
#include <cstdint>

namespace impactx
{
namespace distribution
{
    struct ThermalData
    {
        amrex::ParticleReal tolerance = 1.0e-3; ///< tolerance for matching condition
        amrex::ParticleReal rmin = 1.0e-10;  ///< minimum r value for numerical integration
        amrex::ParticleReal rmax = 10.0;  ///< maximum r value for numerical integration
        int nsteps = 1000;  ///< number of radial steps for numerical integration

        struct Rprofile
        {
            amrex::ParticleReal f1;  ///< cumulative distribution of first population
            amrex::ParticleReal f2;  ///< cumulative distribution of second population
            amrex::ParticleReal phi1;  ///< potential generated by first population
            amrex::ParticleReal phi2; ///< potential generated by second population
            amrex::ParticleReal Q;  ///< bunch charge
            amrex::ParticleReal k;  ///< linear focusing strength (1/meters)
            amrex::ParticleReal T1; ///< temperature k*T of the primary (core) population
            amrex::ParticleReal T2; ///< temperature k*T of the secondary (halo) population
            amrex::ParticleReal w;  ///< weight of the secondary (halo) population

            Rprofile(amrex::ParticleReal Q,
                     amrex::ParticleReal k,
                     amrex::ParticleReal T1,
                     amrex::ParticleReal T2,
                     amrex::ParticleReal w)
            : m_Q(Q),m_k(k),m_T1(T1),m_T2(T2),m_w(w)
            {
                 Q = m_Q;
                 k = m_k;
                 T1 = m_T1;
                 T2 = m_T2;
                 w = m_w;
            }

            private:
                amrex::ParticleReal m_Q; //! bunch charge (C)
                amrex::ParticleReal m_k; //! linear focusing strength (1/meters)
                amrex::ParticleReal m_T1,m_T2; //! temperature of each particle population
                amrex::ParticleReal m_w; //! relative weight of halo population
        };

        void generate_radial_dist (Rprofile & data)

        {
            using namespace amrex::literals; // for _rt and _prt

            // set initial conditions
            data.f1 = 0.0_prt;
            data.f2 = 0.0_prt;
            data.phi1 = 27.5_prt;
            data.phi2 = 0.0_prt;

            // integrate ODEs for the radial density
            integrate(data,rmin,rmax,nsteps);

            // a search over initial conditions will be added

        }

        void integrate (Rprofile & data,
                        amrex::ParticleReal const rin,
                        amrex::ParticleReal const rout,
                        int const nsteps)
        {
            using namespace amrex::literals; // for _rt and _prt

            // initialize numerical integration parameters
            amrex::ParticleReal const dr = (rout-rin)/nsteps;
            amrex::ParticleReal const alpha = 1.0_prt - pow(2.0_prt,1.0/3.0);
            amrex::ParticleReal const tau2 = dr/(1.0_prt + alpha);
            amrex::ParticleReal const tau1 = tau2/2.0_prt;
            amrex::ParticleReal const tau3 = alpha*tau1;
            amrex::ParticleReal const tau4 = (alpha - 1.0_prt)*tau2;
            amrex::ParticleReal const half = dr/2.0_prt;

            // initialize the value of the independent variable
            amrex::ParticleReal reval = rin;

            // loop over integration steps
            for (int j=0; j < nsteps; ++j)
            {
/*             // for a fourth-order Ruth integrator
                map1(tau1,data,reval);
                map2(tau2,data,reval);
                map1(tau3,data,reval);
                map2(tau4,data,reval);
                map1(tau3,data,reval);
                map2(tau2,data,reval);
                map1(tau1,data,reval); */
            // for a second-order Strang splitting
                map1(half,data,reval);
                map2(dr,data,reval);
                map1(half,data,reval);
            // write cumulative density to file for debugging
                amrex::PrintToFile("density1.out") << reval << " " << data.f1 << "\n";
                amrex::PrintToFile("density2.out") << reval << " " << data.f2 << "\n";
                amrex::PrintToFile("phi1.out") << reval << " " << data.phi1 << "\n";
                amrex::PrintToFile("phi2.out") << reval << " " << data.phi2 << "\n";
            }

        }

        void map1 (amrex::ParticleReal const tau,
                   Rprofile & data,
                   amrex::ParticleReal & reval) const
        {
            using namespace amrex::literals; // for _rt and _prt

            amrex::ParticleReal const f1 = data.f1;
            amrex::ParticleReal const f2 = data.f2;
            amrex::ParticleReal const phi1 = data.phi1;
            amrex::ParticleReal const phi2 = data.phi2;
            amrex::ParticleReal const r = reval;
            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;

            // Apply map to update phi1, phi2, and r:
            reval = r + tau;
            data.phi1 = phi1 + f1/(4.0_prt*pi*reval) - f1/(4.0_prt*pi*r);
            data.phi2 = phi2 + f2/(4.0_prt*pi*reval) - f2/(4.0_prt*pi*r);;
            data.f1 = f1;
            data.f2 = f2;

        }

        void map2 (amrex::ParticleReal const tau,
                   Rprofile & data,
                   amrex::ParticleReal & reval) const
        {
            using namespace amrex::literals; // for _rt and _prt

            amrex::ParticleReal const f1 = data.f1;
            amrex::ParticleReal const f2 = data.f2;
            amrex::ParticleReal const phi1 = data.phi1;
            amrex::ParticleReal const phi2 = data.phi2;
            amrex::ParticleReal const r = reval;
            amrex::ParticleReal const k = data.k;
            amrex::ParticleReal const w = data.w;
            amrex::ParticleReal const T1 = data.T1;
            amrex::ParticleReal const T2 = data.T2;
            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;

            // Define intermediate quantities
            amrex::ParticleReal potential = 0.0_prt;
            amrex::ParticleReal const c1 = (1.0_prt-w)*(0.1_prt);
            amrex::ParticleReal const c2 = w*(0.1_prt);
            potential = pow(k*r,2.0)/2.0_prt + c1*phi1 + c2*phi2;
            amrex::ParticleReal Pdensity1 = exp(-potential/T1);
            amrex::ParticleReal Pdensity2 = exp(-potential/T2);

            // Apply map to update f1 and f2:
            data.phi1 = phi1;
            data.phi2 = phi2;
            data.f1 = f1 + tau*4.0_prt*pi*pow(r,2.0)*Pdensity1;
            data.f2 = f2 + tau*4.0_prt*pi*pow(r,2.0)*Pdensity2;
            reval = r;

        }

    };

    struct Thermal
    {
        /** A stationary Thermal or Bi-thermal distribution
         *
         * Return sampling from a 6D bi-thermal distribution, a
         * stationary solution of the Vlasov-Poisson system in
         * an isotropic linear focusing channel.
         *
         * @param k linear focusing strength (1/meters)
         * @param T1 temperature k*T of the primary (core) population
         * @param T2 temperature k*T of the secondary (halo) population
         * @param w weight of the secondary (halo) population
         */
         Thermal(amrex::ParticleReal const k, amrex::ParticleReal const T1,
         amrex::ParticleReal const T2,amrex::ParticleReal const w
         )
          : m_k(k),m_T1(T1),m_T2(T2),m_w(w)
          {
          }

        /** Return 1 6D particle coordinate
         *
         * @param x particle position in x
         * @param y particle position in y
         * @param t particle position in t
         * @param px particle momentum in x
         * @param py particle momentum in y
         * @param pt particle momentum in t
         * @param engine a random number engine (with associated state)
         */
        AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
        void operator() (
                amrex::ParticleReal & x,
                amrex::ParticleReal & y,
                amrex::ParticleReal & t,
                amrex::ParticleReal & px,
                amrex::ParticleReal & py,
                amrex::ParticleReal & pt,
                amrex::RandomEngine const& engine) {

            using namespace amrex::literals;

            amrex::ParticleReal ln1,norm,u1,u2;
            amrex::ParticleReal g1,g2,g3,g4,g5,g6;

            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;

            // Use a Bernoulli random variable to select between core and halo:
            //std::bernoulli_distribution select_population(m_w);
            //bool out = select_population(engine);

            // Generate six standard normal random variables using Box-Muller:
            u1 = amrex::Random(engine);
            u2 = amrex::Random(engine);
            ln1 = sqrt(-2_prt*log(u1));
            g1 = ln1*cos(2_prt*pi*u2);
            g2 = ln1*sin(2_prt*pi*u2);
            u1 = amrex::Random(engine);
            u2 = amrex::Random(engine);
            ln1 = sqrt(-2_prt*log(u1));
            g3 = ln1*cos(2_prt*pi*u2);
            g4 = ln1*sin(2_prt*pi*u2);
            u1 = amrex::Random(engine);
            u2 = amrex::Random(engine);
            ln1 = sqrt(-2_prt*log(u1));
            g5 = ln1*cos(2_prt*pi*u2);
            g6 = ln1*sin(2_prt*pi*u2);

            // Scale the last three variables to produce the momenta:
            px = sqrt(m_T1)*g4;
            py = sqrt(m_T1)*g5;
            pt = sqrt(m_T1)*g6;

            // Normalize the first three variables to produce uniform samples on the unit 3-sphere:
            norm = sqrt(g1*g1+g2*g2+g3*g3);
            g1 /= norm;
            g2 /= norm;
            g3 /= norm;

            // Define a radial CDF for numerical testing
            amrex::ParticleReal rmin = 0.0;
            amrex::ParticleReal rmax = 10.0;
            amrex::ParticleReal r;
            int const nbins = 1000;
            int const length = nbins + 1;
            amrex::ParticleReal cdf[length];
            for (int n = 0; n < nbins; ++n) {
                r = rmin + (rmax-rmin)*(n/(float)(nbins));
                cdf[n] = pow(r/rmax,3);
            }
            cdf[nbins] = 1;

            // Generate a radial coordinate from the CDF
            amrex::ParticleReal u = amrex::Random(engine);
            amrex::ParticleReal *ptr = amrex::lower_bound(cdf, cdf + nbins + 1, u);
            int off = amrex::max(0, (int)(ptr - cdf - 1));
            amrex::ParticleReal tv = (u - cdf[off]) / (cdf[off + 1] - cdf[off]);
            amrex::ParticleReal xv = (off + tv) / (float)(nbins);
            r = rmin + (rmax - rmin) * xv;

            // Scale to produce samples with the correct radial density:
            x = g1*r;
            y = g2*r;
            t = g3*r;

            // Transform logitudinal variables into the laboratory frame:

        }

    private:
        amrex::ParticleReal m_k; //! linear focusing strength (1/meters)
        amrex::ParticleReal m_T1,m_T2; //! temperature of each particle population
        amrex::ParticleReal m_w; //! relative weight of halo population
    };

} // namespace distribution
} // namespace impactx

#endif // IMPACTX_DISTRIBUTION_THERMAL
