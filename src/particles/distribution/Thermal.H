/* Copyright 2022-2023 The Regents of the University of California, through Lawrence
 *           Berkeley National Laboratory (subject to receipt of any required
 *           approvals from the U.S. Dept. of Energy). All rights reserved.
 *
 * This file is part of ImpactX.
 *
 * Authors: Ji Qiang, Axel Huebl
 * License: BSD-3-Clause-LBNL
 */
#ifndef IMPACTX_DISTRIBUTION_THERMAL
#define IMPACTX_DISTRIBUTION_THERMAL

#include <AMReX_Random.H>
#include <AMReX_REAL.H>
#include <AMReX_Print.H>
#include <ablastr/constant.H>
#include "particles/ImpactXParticleContainer.H"

#include <cmath>
#include <cstdint>
#include <random>

namespace impactx
{
namespace distribution
{
    struct ThermalData
    {
        amrex::ParticleReal const tolerance = 1.0e-3; ///< tolerance for matching condition
        amrex::ParticleReal const rin = 1.0e-10;  ///< initial r value for numerical integration
        amrex::ParticleReal const rout = 10.0;  ///< final r value for numerical integration
        int const nsteps = 2000;  ///< number of radial steps for numerical integration

        struct Rprofile
        {
            amrex::ParticleReal f1;  ///< cumulative distribution of first population
            amrex::ParticleReal f2;  ///< cumulative distribution of second population
            amrex::ParticleReal phi1;  ///< potential generated by first population
            amrex::ParticleReal phi2; ///< potential generated by second population
            amrex::ParticleReal p1;  ///< normalization constant of first population
            amrex::ParticleReal p2; ///< normalization constant of second population
            amrex::ParticleReal rmin;  ///< minimum r value for tabulated cdf
            amrex::ParticleReal rmax;  ///< maximum r value for tabulated cdf
            int nbins;  ///< number of radial bins for tabulated cdf
            amrex::ParticleReal cdf1[2001];  ///< tabulated cumulative distribution (first)
            amrex::ParticleReal cdf2[2001];  ///< tabulated cumulative distribution (second)
            amrex::ParticleReal Cintensity;  ///< space charge intensity parameter
            amrex::ParticleReal bg; ///< reference value of relativistic beta*gamma
            amrex::ParticleReal k;  ///< linear focusing strength (1/meters)
            amrex::ParticleReal T1; ///< temperature k*T of the primary (core) population
            amrex::ParticleReal T2; ///< temperature k*T of the secondary (halo) population
            amrex::ParticleReal w;  ///< weight of the secondary (halo) population

            Rprofile(amrex::ParticleReal kin,
                     amrex::ParticleReal T1in,
                     amrex::ParticleReal T2in,
                     amrex::ParticleReal p1in,
                     amrex::ParticleReal p2in,
                     amrex::ParticleReal win)
            {
                 k = kin;
                 T1 = T1in;
                 T2 = T2in;
                 p1 = p1in;
                 p2 = p2in;
                 w = win;
            }

        };

        void generate_radial_dist (amrex::ParticleReal const bunch_charge, RefPart const & refpart, Rprofile & data)

        {
            using namespace amrex::literals; // for _rt and _prt

            // Get relativistic beta*gamma
            amrex::ParticleReal bg = refpart.beta_gamma();
            data.bg = bg;

            // Get reference particle rest energy (eV) and charge (q_e)
            amrex::ParticleReal Erest = refpart.mass_MeV()*1.0e6;
            amrex::ParticleReal q_e = refpart.charge_qe();

            // Set space charge intensity
            data.Cintensity = q_e*bunch_charge/(pow(bg,2)*Erest*ablastr::constant::SI::ep0);

            // Set minimum and maximum radius
            amrex::ParticleReal r_scale = matched_scale_radius(data);
            amrex::ParticleReal rmin = rin*r_scale;
            amrex::ParticleReal rmax = rout*r_scale;
            amrex::PrintToFile("equilibrium_params.out") << r_scale << " " << data.Cintensity << "\n";

            // Scale the parameters p1 and p2
            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;
            amrex::ParticleReal rt2pi = sqrt(2.0_prt*pi);
            amrex::ParticleReal p_scale = pow(r_scale*rt2pi,-3);
            data.p1 = data.p1*p_scale;
            data.p2 = data.p2*p_scale;

            // store integration parameters
            data.nbins = nsteps;
            data.rmin = rmin;
            data.rmax = rmax;

            // set initial conditions
            data.f1 = 0.0_prt;
            data.f2 = 0.0_prt;
            data.phi1 = 0.0_prt;
            data.phi2 = 0.0_prt;
            data.cdf1[0] = 0.0_prt;
            data.cdf2[0] = 0.0_prt;

            // integrate ODEs for the radial density
            integrate(data,rmin,rmax,nsteps);

            // a search over normalization parameters p1, p2 can be added here

        }

        amrex::ParticleReal
        matched_scale_radius(Rprofile & data)
        {
            using namespace amrex::literals; // for _rt and _prt
            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;

            amrex::ParticleReal k = data.k;
            amrex::ParticleReal kT = (1.0_prt-data.w)*data.T1 + data.w*data.T2;
            amrex::ParticleReal a = data.Cintensity/(4.0_prt*pi*5.0_prt*sqrt(5.0_prt));
            amrex::ParticleReal rscale = sqrt(kT + pow(a*k,2.0/3.0))/k;

            return rscale;
        }

        void integrate (Rprofile & data,
                        amrex::ParticleReal const in,
                        amrex::ParticleReal const out,
                        int const steps)
        {
            using namespace amrex::literals; // for _rt and _prt

            // initialize numerical integration parameters
            amrex::ParticleReal const tau = (out-in)/steps;
            amrex::ParticleReal const half = tau/2.0_prt;

            // initialize the value of the independent variable
            amrex::ParticleReal reval = in;

            // loop over integration steps
            for (int j=0; j < steps; ++j)
            {
            // for a second-order Strang splitting
                map1(half,data,reval);
                map2(tau,data,reval);
                map1(half,data,reval);
            // store tabulated CDF
                data.cdf1[j+1] = data.f1;
                data.cdf2[j+1] = data.f2;
            // write cumulative density to file for debugging
                amrex::PrintToFile("density1.out") << reval << " " << data.f1 << "\n";
                amrex::PrintToFile("density2.out") << reval << " " << data.f2 << "\n";
                amrex::PrintToFile("phi1.out") << reval << " " << data.phi1 << "\n";
                amrex::PrintToFile("phi2.out") << reval << " " << data.phi2 << "\n";
            }

        }

        void map1 (amrex::ParticleReal const tau,
                   Rprofile & data,
                   amrex::ParticleReal & reval) const
        {
            using namespace amrex::literals; // for _rt and _prt

            amrex::ParticleReal const f1 = data.f1;
            amrex::ParticleReal const f2 = data.f2;
            amrex::ParticleReal const phi1 = data.phi1;
            amrex::ParticleReal const phi2 = data.phi2;
            amrex::ParticleReal const r = reval;
            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;

            // Apply map to update phi1, phi2, and r:
            reval = r + tau;
            data.phi1 = phi1 + f1/(4.0_prt*pi*reval) - f1/(4.0_prt*pi*r);
            data.phi2 = phi2 + f2/(4.0_prt*pi*reval) - f2/(4.0_prt*pi*r);;
            data.f1 = f1;
            data.f2 = f2;

        }

        void map2 (amrex::ParticleReal const tau,
                   Rprofile & data,
                   amrex::ParticleReal & reval) const
        {
            using namespace amrex::literals; // for _rt and _prt

            amrex::ParticleReal const f1 = data.f1;
            amrex::ParticleReal const f2 = data.f2;
            amrex::ParticleReal const phi1 = data.phi1;
            amrex::ParticleReal const phi2 = data.phi2;
            amrex::ParticleReal const r = reval;
            amrex::ParticleReal const k = data.k;
            amrex::ParticleReal const w = data.w;
            amrex::ParticleReal const T1 = data.T1;
            amrex::ParticleReal const T2 = data.T2;
            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;

            // Define space charge intensity parameters
            amrex::ParticleReal const c1 = (1.0_prt-w)*data.Cintensity;
            amrex::ParticleReal const c2 = w*data.Cintensity;

            // Define intermediate quantities
            amrex::ParticleReal potential = 0.0_prt;
            potential = pow(k*r,2.0)/2.0_prt + c1*phi1 + c2*phi2;
            amrex::ParticleReal Pdensity1 = data.p1*exp(-potential/T1);
            amrex::ParticleReal Pdensity2 = data.p2*exp(-potential/T2);
            amrex::ParticleReal Pdensity_tot = (1.0_prt-w)*Pdensity1 + w*Pdensity2;
            amrex::PrintToFile("Pdensity.out") << reval << " " << Pdensity_tot << "\n";

            // Apply map to update f1 and f2:
            data.phi1 = phi1;
            data.phi2 = phi2;
            data.f1 = f1 + tau*4.0_prt*pi*pow(r,2.0)*Pdensity1;
            data.f2 = f2 + tau*4.0_prt*pi*pow(r,2.0)*Pdensity2;
            reval = r;

        }

    };

    struct Thermal
    {
        /** A stationary Thermal or Bi-thermal distribution
         *
         * Return sampling from a 6D bi-thermal distribution, a
         * stationary solution of the Vlasov-Poisson system in
         * an isotropic linear focusing channel.
         *
         * @param k linear focusing strength (1/meters)
         * @param T1 temperature k*T of the primary (core) population
         * @param T2 temperature k*T of the secondary (halo) population
         * @param w weight of the secondary (halo) population
         */
         Thermal([[maybe_unused]] amrex::ParticleReal const k,
                 [[maybe_unused]] amrex::ParticleReal const T1,
                 [[maybe_unused]] amrex::ParticleReal const T2,
                 [[maybe_unused]] amrex::ParticleReal const w,
                 ThermalData::Rprofile const data
         )
          : m_k(k),m_T1(T1),m_T2(T2),m_w(w),m_data(data)
          {
          }

        /** Return 1 6D particle coordinate
         *
         * @param x particle position in x
         * @param y particle position in y
         * @param t particle position in t
         * @param px particle momentum in x
         * @param py particle momentum in y
         * @param pt particle momentum in t
         * @param engine a random number engine (with associated state)
         */
        AMREX_GPU_HOST_DEVICE AMREX_FORCE_INLINE
        void operator() (
                amrex::ParticleReal & x,
                amrex::ParticleReal & y,
                amrex::ParticleReal & t,
                amrex::ParticleReal & px,
                amrex::ParticleReal & py,
                amrex::ParticleReal & pt,
                amrex::RandomEngine const& engine) {

            using namespace amrex::literals;

            amrex::ParticleReal ln1,norm,u1,u2,uhalo;
            amrex::ParticleReal g1,g2,g3,g4,g5,g6;
            amrex::ParticleReal z,pz;

            constexpr amrex::ParticleReal pi = 3.14159265358979_prt;

            // Use a Bernoulli random variable to select between core and halo:
            // If u < w, the particle is in the halo population.
            // If u >= w, the particle is in the core population.
            uhalo = amrex::Random(engine);

            // Generate six standard normal random variables using Box-Muller:
            u1 = amrex::Random(engine);
            u2 = amrex::Random(engine);
            ln1 = sqrt(-2_prt*log(u1));
            g1 = ln1*cos(2_prt*pi*u2);
            g2 = ln1*sin(2_prt*pi*u2);
            u1 = amrex::Random(engine);
            u2 = amrex::Random(engine);
            ln1 = sqrt(-2_prt*log(u1));
            g3 = ln1*cos(2_prt*pi*u2);
            g4 = ln1*sin(2_prt*pi*u2);
            u1 = amrex::Random(engine);
            u2 = amrex::Random(engine);
            ln1 = sqrt(-2_prt*log(u1));
            g5 = ln1*cos(2_prt*pi*u2);
            g6 = ln1*sin(2_prt*pi*u2);

            // Scale the last three variables to produce the momenta:
            amrex::ParticleReal kT = (uhalo > m_data.w) ? m_data.T1 : m_data.T2;  // select core or halo value
            px = sqrt(kT)*g4;
            py = sqrt(kT)*g5;
            pz = sqrt(kT)*g6;

            // Normalize the first three variables to produce uniform samples on the unit 3-sphere:
            norm = sqrt(g1*g1+g2*g2+g3*g3);
            g1 /= norm;
            g2 /= norm;
            g3 /= norm;

            // Collect the radial CDF returned by generate_radial_dist:
            amrex::ParticleReal rmin = m_data.rmin;
            amrex::ParticleReal rmax = m_data.rmax;
            int const nbins = m_data.nbins;
            int const length = 2001;  //Ideally, int const length = nbins + 1;
            amrex::ParticleReal cdf[length];
            for (int n = 0; n < length; ++n) {
                cdf[n] = (uhalo > m_data.w) ? m_data.cdf1[n] : m_data.cdf2[n]; //select core or halo CDF
            }
            for (int n = 0; n < length; ++n) {
                cdf[n] = cdf[n]/cdf[nbins];  //rescale cdf to ensure the exact range [0,1]
            }

            // Generate a radial coordinate from the CDF
            amrex::ParticleReal u = amrex::Random(engine);
            amrex::ParticleReal *ptr = amrex::lower_bound(cdf, cdf + nbins + 1, u);
            int off = amrex::max(0, (int)(ptr - cdf - 1));
            amrex::ParticleReal tv = (u - cdf[off]) / (cdf[off + 1] - cdf[off]);
            amrex::ParticleReal xv = (off + tv) / (float)(nbins);
            amrex::ParticleReal r = rmin + (rmax - rmin) * xv;

            // Scale to produce samples with the correct radial density:
            x = g1*r;
            y = g2*r;
            z = g3*r;

            // Transform logitudinal variables into the laboratory frame:
            t = -z/(m_data.bg);
            pt = -pz*(m_data.bg);

        }

    private:
        [[maybe_unused]] amrex::ParticleReal m_k; //! linear focusing strength (1/meters)
        [[maybe_unused]] amrex::ParticleReal m_T1,m_T2; //! temperature of each particle population
        [[maybe_unused]] amrex::ParticleReal m_w; //! relative weight of halo population
        ThermalData::Rprofile m_data; //! struct containing radial profile data
    };

} // namespace distribution
} // namespace impactx

#endif // IMPACTX_DISTRIBUTION_THERMAL
